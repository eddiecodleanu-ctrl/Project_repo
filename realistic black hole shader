"""
blackhole_shader.py
Run with: python blackhole_shader.py
Dependencies: moderngl, moderngl-window, numpy
"""

import moderngl
import moderngl_window as mglw
from moderngl_window import geometry

# ----------------------------
# Vertex shader
# ----------------------------
VS = """
#version 330 core
in vec3 in_position;      // match what geometry.quad_fs provides
in vec2 in_texcoord_0;    // texture coordinates from quad_fs
out vec2 vUv;

void main() {
    vUv = in_texcoord_0;                // directly use the provided texcoords
    gl_Position = vec4(in_position, 1.0);
}

"""

# ----------------------------
# Fragment shader
# ----------------------------
FS = """
#version 330 core
precision highp float;

in vec2 vUv;
out vec4 fragColor;

uniform vec2 iResolution;
uniform float iTime;
uniform vec2 iMouse;

uniform float u_mass;
uniform float u_eventHorizon;

#define STEPS 220

float hash21(vec2 p){ return fract(sin(dot(p, vec2(127.1,311.7))) * 43758.5453123); }

vec3 palette(float t){ return vec3(0.5 + 0.5*cos(6.2831853*(t + vec3(0.0,0.33,0.67)))); }

void main() {
    vec2 uv = (vUv * 2.0 - 1.0) * vec2(iResolution.x / iResolution.y, 1.0);

    float ang = iTime * 0.07;
    vec3 camPos = vec3(6.0 * cos(ang), 1.0, 6.0 * sin(ang));
    vec3 target = vec3(0.0);
    vec3 up = vec3(0.0, 1.0, 0.0);

    vec3 fwd = normalize(target - camPos);
    vec3 right = normalize(cross(fwd, up));
    vec3 camUp = cross(right, fwd);

    vec3 rayDir = normalize(fwd + uv.x * right + uv.y * camUp);

    vec3 pos = camPos;
    vec3 dir = rayDir;
    float dt = 0.035;

    vec3 accumColor = vec3(0.0);
    bool captured = false;

    for (int i = 0; i < STEPS; ++i) {
        float rlen = length(pos);
        if (rlen < u_eventHorizon) { captured = true; break; }

        if (abs(pos.y) < 0.08) {
            float rad = length(pos.xz);
            if (rad > u_eventHorizon * 1.05 && rad < 8.0) {
                float emiss = pow(1.0 / (rad + 0.1), 2.0);
                float dop = clamp(dot(normalize(vec3(1.0, 0.0, 0.0)), dir), -1.0, 1.0);
                vec3 col = palette(fract(0.6 / (0.1 + rad * 0.06) + dop * 0.1 + hash21(pos.xz) * 0.02));
                accumColor += col * emiss * 0.7;
            }
        }

        float G = u_mass;
        float soften = 0.25;
        float denom = pow(rlen * rlen + soften, 1.5);
        vec3 a = -G * pos / denom;

        dir += a * dt;
        dir = normalize(dir);
        pos += dir * dt;
    }

    vec3 bg = vec3(0.0);
    if (!captured) {
        float star = pow(max(0.0, dot(normalize(dir), vec3(0.0,1.0,0.0))), 40.0);
        float st = hash21(dir.xy * 1234.0 + floor(iTime * 0.1));
        bg += vec3(star) * (0.6 + 0.4 * st);
    }

    float photonSphereR = 1.5 * u_eventHorizon;
    float near = length(pos);
    float ring = exp(-pow((near - photonSphereR) * 0.9, 2.0)) * 1.4;
    vec3 ringCol = palette(0.08 + 0.6 * fract(iTime * 0.02));

    vec3 color = bg + accumColor;
    color += ringCol * ring;

    if (captured) { color = vec3(0.0); }

    color = color / (1.0 + color);
    color = pow(color, vec3(0.4545));

    fragColor = vec4(color, 1.0);
}
"""

# ----------------------------
# Python Application
# ----------------------------
class BlackHoleApp(mglw.WindowConfig):
    gl_version = (3, 3)
    title = "Black Hole Shader (Python + GLSL)"
    window_size = (1280, 720)
    aspect_ratio = None
    resizable = True
    resource_dir = "."

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.program = self.ctx.program(vertex_shader=VS, fragment_shader=FS)
        self.quad = geometry.quad_fs()

        self.mass = 0.5
        self.event_horizon = 0.1
        self.mouse_pos = (0.0, 0.0)

        self.u_iResolution = self.program.get("iResolution", None)
        self.u_iTime = self.program.get("iTime", None)
        self.u_iMouse = self.program.get("iMouse", None)
        self.u_mass = self.program.get("u_mass", None)
        self.u_eventHorizon = self.program.get("u_eventHorizon", None)

    def on_render(self, time: float, frame_time: float):
        self.ctx.clear(0.0, 0.0, 0.0)
        w, h = self.wnd.buffer_width, self.wnd.buffer_height
        if self.u_iResolution:
            self.u_iResolution.value = (float(w), float(h))
        if self.u_iTime:
            self.u_iTime.value = float(time)
        if self.u_iMouse:
            mx, my = self.mouse_pos
            self.u_iMouse.value = (float(mx), float(my))
        if self.u_mass:
            self.u_mass.value = float(self.mass)
        if self.u_eventHorizon:
            self.u_eventHorizon.value = float(self.event_horizon)
        self.quad.render(self.program)

    def key_event(self, key, action, mods):
        keys = mglw.keys
        if action != self.wnd.keys.ACTION_PRESS:
            return
        if key == keys.ESCAPE:
            self.wnd.close()
        elif key == keys.UP:
            self.mass *= 1.12
        elif key == keys.DOWN:
            self.mass /= 1.12
        elif key == keys.RIGHT:
            self.event_horizon *= 1.05
        elif key == keys.LEFT:
            self.event_horizon /= 1.05

    def mouse_position_event(self, x, y, dx, dy):
        self.mouse_pos = (x, y)


if __name__ == "__main__":
    mglw.run_window_config(BlackHoleApp)
